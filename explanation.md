Code snippet 1

This code snippet contains the depth-first search algorithm I created to check if there is still a legal path for both players to reach the finish. It is used before a wall is placed to check if the player is able to place it there. I decide to go with depth-first search as I only need to find one way to reach the finish and I wanted it done efficiently. The first argument taken in for the function is the current position of the player we are checking the legal path for. The next argument is a string that contains the direction the player needs to go to reach the finish as both players go opposite ways. The third argument is the wall list that will be used when checking for the path. First, there is a stack initialized with the first position. The stack will contain all squares that we know the player can get to currently from their location. Also, a visited set is initialized that will contain all squares already visited so the algorithm will not go in circles. Next, there is a while loop created that will check the stack length everytime it runs. If the stack is ever empty, then we know that the there are no more possible locations for the player to go to. In the while loop, the last element in the stack is popped since we are using a dfs. This element is "current" position of the player during the search. If the player is going north and they are in one of the top 5 squares, then we know there is a legal path to the finish so we can return true. This is the same for a player going towards the south side of the board and is in one of the bottom 5 squares. Otherwise, the algorithm needs to keep searching. Next up, it will first check if the current position has already been visited, if it has then the program will go back to the top of the loop and pop off the next element of the stack and try again. If it hasn't been visited, then the algorithm will check all the neighbours of the current square as long as there is no walls in the way. The algorithm calls the function legalMove() which returns a list of legal directions for the current position. Then, depending on the direction for each element in the list, the algorithm will add the next square in that direction to the stack. The squares are numbered from 0 to 24 with 0 being in the top left and 24 being the bottom right. So if a player wanted to move north, then the next position north would be the (current position - 5) as it is in the row above. If the player wanted to go east or west then since it is in the same row then it would be (current position + or - 1). If they wanted to go south then it would be +5 as it is the row below which contains the higher numbers. These are calculated in lines 377-385. If the stack is empty then we know that the algorithm did not find a path so it returns false. 


Code snippet 2

This code snippet contains the function legal move, which checks the directions a player can move from their current position and returns a list of said directions. It takes in the players position and a list of all walls on the board. It then goes through each direction starting with north. It first checks that the player is not on the edge of the board as then they would not be able to move in that direction anymore. If the player wants to go north then they cannot be on the top row as there are no squares above. If theya re not on the top row then it checks if there is a wall between the current position and the square to the north. It does this by checking if the wall in between the squares is currently in the wall list. Each wall has their own id that is used in the html and has been added to the wall list. It starts with "wall" and then contains an "x" or "y" depending on the direction the wall is going in. After, it contains the row number which is from 1-5 with 1 being at the top and then a letter from a-e which represent the columns from left to right. For the rows, they start after the squares so row 1 of the walls is right underneath row 1 of the squares. The code checks the wall list by creating a string of "wall" then the "x" or "y" depending on the direction of the wall and then appending the row number and column letter. To get the row and column of the wall, we need to use the squareList whcih contains all of the ids for the squares in the proper index. When the current position is put into the squareList, then the id of that square is taken out. The squares have the same ids as the walls except there is no "wally" or "wallx" in front. For the north direction, the player will be going up to the row above so we need to change the position by -5 to get to the proper wall. If the list doesn't include the wall, then the player can move there so the direction is added to the direction list. For west and east, we need to check the sides of the board through modulo, as the squares on the far left of the board will all be a multple of 5 which will become 0 with the modulo function. The squares on the far right will go up by 5 starting with the number 4 so that will always be 4 using modulo. Since the horizontal walls will always be right below the square of the same id, whenw e are checking south we use the same position. The vertical walls are always to thr right of the square so when checking west we also use the same position. The fuinction then returns a list of all the directions that are possible


Code snippet 3

This last code snippet is taken from the placeWall() function. In this part, the code gets the second part of the wall from the first one as the walls take up two squares. In the html, each wall takes up a single square so to get it to be double then you need to get the id of the wall next to it. Th id variable is the id of the current wall that has been clicked by the user. The cide first checks if the wall is a horizontal wall or vertical wall. If it is vertical then the id will contain "wally" at the beginning. If it is horizontal then it will contain "wallx". If it is a vertical wall, then we need the wall below it as it is the next part of the double wall. SO the code slices id which takes the string id and copies the characters at a certain index specified in the arguments. In this case, the row number of the id is in position 5 for all of the walls so the slice gets that number and stores it in the variable num. Then, num is incremented to get to the next row below. The id of the second wall is then stored in the variable id2 with a string being appended on line 295. Since it is a vertical wall, "wally" is added to the beginning, then the new row number is appended. After, a blank string is appended so the two number variables are not added to each other. Finally, the column letter is appended to the back of the string since the new vertical wall will be in the same column. Now, id2 stores the id of the wall directly below the wall that was clicked by the player. If the wall clicked was a horizontal wall, then we need the wall in the next column instead. Since, the columns are represented by letters, we need the next letter. To get this, the code converts the letter into it's ASCII code and then adds 1. Since all letters are in the same order a their ASCII codes, we will get the next letter in the alphabet. Next, the code creates the new wall id by adding "wallx" and then the same row number as the wall in id. Then, it converts the ASCII code back into the letter of the next column and appends it to the end of the string
